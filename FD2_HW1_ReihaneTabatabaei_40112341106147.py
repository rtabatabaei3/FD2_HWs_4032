# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DS5ThqVePTbIVmgvMuyzoEzvXOtJ9-Xh
"""

import numpy as np
import math
# سوال اول
def first(V, phi_deg):
    phi = math.radians(phi_deg)
    g = 9.81
    R = (V**2) / (g * math.tan(phi))
    omega_inertial = V / R
    omega_body = [
        0,
        omega_inertial * math.sin(phi),
        omega_inertial * math.cos(phi)
    ]
    return {
        "Angular_velocity_in_inertial_frame": [omega_inertial],
        "Angular_velocity_in_body_frame": omega_body
    }
result = first(250, 60)
print(result)

def third(C):
    I = np.eye(3)
    is_orthogonal = np.allclose(np.dot(C, C.T), I)
    det = np.linalg.det(C)
    return is_orthogonal and np.isclose(det, 1.0)

def rotation_matrix_to_params(C):
    if not third(C):
        return "matrix does mot have rotational matrix conditions."

    theta = np.arcsin(-C[2, 0])
    psi = np.arctan2(C[1, 0]/np.cos(theta), C[0, 0]/np.cos(theta))
    phi = np.arctan2(C[2, 1]/np.cos(theta), C[2, 2]/np.cos(theta))
    euler_angles = [np.degrees(psi), np.degrees(theta), np.degrees(phi)]

    q0 = 0.5 * np.sqrt(1 + C[0, 0] + C[1, 1] + C[2, 2])
    q1 = (C[1, 2] - C[2, 1]) / (4 * q0)
    q2 = (C[2, 0] - C[0, 2]) / (4 * q0)
    q3 = (C[0, 1] - C[1, 0]) / (4 * q0)
    quaternion = [q0, q1, q2, q3]

    rotation_vector = [psi, theta, phi]

    return {
        "Euler_angles": euler_angles,
        "Quaternion_vector": quaternion,
        "Rotation_vector": rotation_vector
    }

C = np.array([
    [0.2802, 0.1387, 0.9499],
    [0.1962, 0.9603, -0.1981],
    [-0.9397, 0.2418, 0.2418]
])
result = rotation_matrix_to_params(C)
print(result)

# سوال دوم
def calculate_euler_angles_and_rates(omegaـbody):

    # omega_body = [p, q, r]
    p, q, r = omega_body

    phi = math.atan2(q, r)

    theta = math.atan2(-p, (math.sin(phi) * q + math.cos(phi) * r))

    sai_dot = (math.sin(phi) / math.cos(theta)) * q + (math.cos(phi) / math.cos(theta)) * r


    sai = 0.0


    euler_angles = [phi, theta, sai]


    euler_angles_rate = [0.0, 0.0, sai_dot]

    return {
        'Euler_angles': euler_angles,
        'Euler_angles_rate': euler_angles_rate
    }

omega_body = [0.33, 0.28, 0.16]

result = calculate_euler_angles_and_rates(omega_body)
print(result)

# سوال سوم
def bonus(omega, phase):
    omega_x, omega_y, omega_z = omega
    Omega = np.array([
        [0, -omega_z, omega_y],
        [omega_z, 0, -omega_x],
        [-omega_y, omega_x, 0]
    ])

    if phase == "Cruise":
        #Cruise
        return Omega
    elif phase == "Pull-up":
        #Pull-up
        return Omega
    elif phase == "Coordinated-turn":
        #Coordinated-turn
        return Omega
    else:
        return "not a valid phase"